def compute_reward(self, q, u):
        """
        Calculates the reward for given states and control inputs.

        ## Action Space
        - u (np.ndarray): The action is a `ndarray` with shape `(1,)`,
        There are four discrete actions available:
        - 0: do nothing
        - 1: fire left orientation engine
        - 2: fire main engine
        - 3: fire right orientation engine

        ## Observation Space
        q (np.ndarray): The state is an 8-dimensional vector: the coordinates of the lander in `x` & `y`, its linear
        velocities in `x` & `y`, its angle, its angular velocity, and two booleans
        that represent whether each leg is in contact with the ground or not.

        ## Starting State
        The lander starts at the top center of the viewport with a random initial
        force applied to its center of mass.

        ## Episode Termination
        The episode finishes if:
        1. the lander crashes (the lander body gets in contact with the moon);
        2. the lander gets outside of the viewport (`x` coordinate is greater than 1);
        3. the lander is not awake. From the [Box2D docs](https://box2d.org/documentation/md__d_1__git_hub_box2d_docs_dynamics.html#autotoc_md61),
            a body which is not awake is a body which doesn't move and doesn't
            collide with any other body:
        > When Box2D determines that a body (or group of bodies) has come to rest,
        > the body enters a sleep state which has very little CPU overhead. If a
        > body is awake and collides with a sleeping body, then the sleeping body
        > wakes up. Bodies will also wake up if a joint or contact attached to
        > them is destroyed.

        ## Arguments

        Lunar Lander has a large number of arguments


        * `continuous` determines if discrete or continuous actions (corresponding to the throttle of the engines) will be used with the
        action space being `Discrete(4)` or `Box(-1, +1, (2,), dtype=np.float32)` respectively.
        For continuous actions, the first coordinate of an action determines the throttle of the main engine, while the second
        coordinate specifies the throttle of the lateral boosters. Given an action `np.array([main, lateral])`, the main
        engine will be turned off completely if `main < 0` and the throttle scales affinely from 50% to 100% for
        `0 <= main <= 1` (in particular, the main engine doesn't work  with less than 50% power).
        Similarly, if `-0.5 < lateral < 0.5`, the lateral boosters will not fire at all. If `lateral < -0.5`, the left
        booster will fire, and if `lateral > 0.5`, the right booster will fire. Again, the throttle scales affinely
        from 50% to 100% between -1 and -0.5 (and 0.5 and 1, respectively).

        The environemnt will be continuous.

        * `gravity` dictates the gravitational constant, this is bounded to be within 0 and -12. Default is -10.0

        * `enable_wind` determines if there will be wind effects applied to the lander. The wind is generated using
        the function `tanh(sin(2 k (t+C)) + sin(pi k (t+C)))` where `k` is set to 0.01 and `C` is sampled randomly between -9999 and 9999.

        * `wind_power` dictates the maximum magnitude of linear wind applied to the craft. The recommended value for
        `wind_power` is between 0.0 and 20.0.

        * `turbulence_power` dictates the maximum magnitude of rotational wind applied to the craft.
        The recommended value for `turbulence_power` is between 0.0 and 2.0.

        **Note**:

        There are several unexpected bugs with the implementation of the environment.

        1. The position of the side thrusters on the body of the lander changes, depending on the orientation of the lander.
        This in turn results in an orientation dependent torque being applied to the lander.

        2. The units of the state are not consistent. I.e.
        * The angular velocity is in units of 0.4 radians per second. In order to convert to radians per second, the value needs to be multiplied by a factor of 2.5.

        For the default values of VIEWPORT_W, VIEWPORT_H, SCALE, and FPS, the scale factors equal:
        'x': 10, 'y': 6.666, 'vx': 5, 'vy': 7.5, 'angle': 1, 'angular velocity': 2.5

        After the correction has been made, the units of the state are as follows:
        'x': (units), 'y': (units), 'vx': (units/second), 'vy': (units/second), 'angle': (radians), 'angular velocity': (radians/second)
        
        Returns:
        - float: The calculated rewards for the states and inputs.        
        """

        return ...
